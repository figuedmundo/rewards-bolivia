# Project Structure Feedback

# Primary issues & risks (what I found)

1. **Thin separation of shared logic vs feature code.**
    - Right now core app code appears organized per-module (DDD), but there is not a visible `libs/` or `shared/` area for cross-cutting code (DTOs shared between api & web, common validation, design tokens, types). Without that, duplication and coupling will grow as features multiply.
2. **Missing explicit runtime worker / batch zone.**
    - For your off-chain fast balances + periodic on-chain consolidation/audit you will need background jobs, schedulers and idempotent workers. There’s no explicit package for workers, jobs, or cron processors.
3. **Infra and deployment artifacts mixed.**
    - `infra/` exists, but we should split local dev infra (docker-compose) from production provisioning (terraform / k8s) and include clear env/secrets guidance and deployment manifests per environment.
4. **Monorepo package boundaries need tightening.**
    - `packages/api` and `packages/web` exist — good — but you’ll benefit from additional packages for `shared-types`, `sdk` (API client), `mobile` (when you add mobile), `worker`, and `admin-dashboard` if planned.
5. **Tests & CI are present but need clearer ownership.**
    - Tests are present in both packages; CI workflow should run lint/tests for changed packages, build artifacts and run integration tests (including prisma migrations). Enforce migration policy.
6. **Naming conventions: `I` prefix for interfaces in TypeScript is questionable.**
    - The doc prescribes `IUserRepository`. In TypeScript the `I` prefix is less common in modern code — optional preference. If you keep it, be consistent.
7. **DB migration & schema lifecycle needs rules.**
    - Prisma migrations exist (several recent migrations listed). Need strict rules for migration generation, review and CI checks to avoid drift between environments.
8. **No explicit SDK for clients or open API contracts.**
    - Provide an autogenerated OpenAPI / client SDK to ensure frontend, mobile and third-party integrations remain consistent.
9. **Missing observable and monitoring tooling guidance.**
    - For financial flows (points), include requirement for observability (structured logging, tracing, metrics), and error compensation strategies.

---

# High-level recommendations (why & what)

1. **Keep Modular Monolith but strengthen module boundaries.**
    - Keep the one-deploy monolith for now (reduces ops complexity), but enforce clear boundaries with well-defined interfaces and `packages/*` libraries so modules can be extracted later if needed.
2. **Adopt a multi-package monorepo layout (add `libs/` and `services/`).**
    - Move shared code to `packages/libs/*` (types, utils, domain value objects, validation, auth types).
    - Create explicit `packages/worker` for background processing (consolidation to on-chain, reconciliation jobs, email, push notifications).
    - Add `packages/sdk` or auto-generated OpenAPI client.
3. **Separate infra into `infra/local` and `infra/prod` with deployment docs.**
    - Keep `docker-compose` for dev in `infra/local`.
    - Keep k8s manifests and terraform under `infra/prod`.
    - Add `infra/README.md` with explicit steps for dev vs prod.
4. **Stronger CI that is package-aware.**
    - Lint/test/build only affected packages in PRs. Always run Prisma migration check and e2e suite for releases.
5. **Add observability and SRE artifacts.**
    - Logging standard (JSON), tracing (opentelemetry), metrics (Prometheus + Grafana dashboards). For point flows, create alerts on reconciliation divergence.
6. **Establish a migration policy & migration-test practice.**
    - PRs that change prisma schema must include a migration and a db smoke-test script; CI must apply migrations in a staging DB and run contract tests.
7. **Provide a Developer Experience (DX) layer.**
    - Add `devbox` scripts, `make`/`justfile` or `pnpm` scripts that set up environment quickly (DB, redis, seed, run worker, run api, run web).
8. **Type strategy: shared-types + OpenAPI-first for contracts.**
    - Generate client types from backend OpenAPI and keep `packages/shared-types` as single source of truth.

---

# Concrete proposed repo structure

Below is a concrete, slightly expanded monorepo layout that keeps the current packages but extends and clarifies responsibilities.

```
/rewards-bolivia
├── packages/
│   ├── api/                    # NestJS app (modular monolith)
│   │   ├── src/
│   │   │   ├── modules/
│   │   │   │   ├── auth/
│   │   │   │   ├── users/
│   │   │   │   ├── transactions/
│   │   │   │   ├── points/            # domain implementing points logic
│   │   │   │   └── reconciliation/    # reconciliation use cases
│   │   │   ├── application/           # cross-module application orchestration
│   │   │   ├── domain/                # pure domain (entities, vobjects)
│   │   │   └── infrastructure/
│   │   ├── prisma/                    # schema + migrations + seeds
│   │   ├── Dockerfile.dev
│   │   └── Dockerfile.prod
│   ├── web/                    # React web app (Vite)
│   ├── mobile/                 # (future) React Native / Expo app
│   ├── worker/                 # Background worker (worker.ts) — bullmq / bee-queue
│   ├── shared-types/           # TypeScript types and DTO contracts
│   ├── sdk/                    # Auto-generated JS/TS client from OpenAPI
│   ├── libs/                   # small reusable libraries
│   │   ├── logger/
│   │   ├── auth/
│   │   └── utils/
│   └── infra-scripts/          # helper scripts for infra e.g. terraform helpers
├── infra/
│   ├── local/                  # docker-compose.yml, docker-compose.override.yml
│   └── prod/                   # k8s manifests, helm charts, terraform
├── .github/workflows/
├── docs/
│   ├── ARCHITECTURE.md
│   ├── RUNBOOKS/
│   └── SECURITY.md
├── scripts/                    # repo-level scripts (setup, seed, migration helpers)
├── package.json                # workspace definitions
└── README.md

```

**Key notes about this layout:**

- `packages/worker` holds job processors (consolidations, refunds, retry logic). This prevents long-running or scheduled tasks from interfering with request latency.
- `packages/shared-types` is used by `web`, `mobile`, and `sdk` so DTOs and domain types are consistent.
- `packages/sdk` generated by OpenAPI; used in frontend and mobile to avoid hand-rolled clients.
- `libs/logger` centralizes structured logging and correlation IDs for tracing.
- `infra/local` vs `infra/prod` avoids accidental use of production terraform in local dev.

---

# File-level remarks (based on files you already have)

- You already have Prisma with multiple migrations (initial, google oauth, role added). Keep this but add a policy:
    - Every schema change -> PR with generated migration + an acceptance test that runs migration and performs schema assertions (seeded DB). (Prisma files observed in your repo are evidence of active migrations.)
- Dockerfiles for dev/prod exist for api and web — good. Standardize environment variable files and secrets handling (do not commit `.env`). Use a secrets store for production (Vault/Secrets Manager).
- Tests: you have unit and e2e tests. Add package-level test scripts and a staged CI pipeline:
    - `npm run lint` → `npm run test:unit` → `npm run test:e2e:staging` → `build` → `deploy`.
- Add an API contract (OpenAPI) generator in `api` and use it to generate `packages/sdk` and `packages/shared-types`.

---

# Migration plan (incremental, no disruption)

Make changes incrementally. Do not try to refactor everything at once.

1. **Establish `packages/shared-types` and `libs/logger`**
    - Move common DTOs/types from `api` into `shared-types`.
    - Update `web` import to reference `shared-types` (use path mapping in TS).
2. **Create `packages/worker` (initial stub)**
    - Implement a simple worker that can be started in local dev. Add a “reconciliation job” placeholder which will eventually do on-chain consolidation.
3. **Split infra into `infra/local` and `infra/prod`**
    - Move existing docker-compose files to `infra/local`.
    - Create `infra/prod` with a simple k8s manifest for `api` and `web` (can be minimal for now).
4. **Add OpenAPI generation & SDK**
    - Add a route to generate OpenAPI spec from NestJS (swagger).
    - Add a CI step that publishes/updates `packages/sdk`.
5. **CI improvements**
    - Add change detection so PR runs tests only for affected packages at minimum; full suite for merges to main.
6. **Add migration & DB smoke test to CI**
    - CI runs `prisma migrate deploy` on a throwaway database and runs smoke tests.
7. **Add observability**
    - Add structured logger lib and link it to `api` and `worker`.
    - Add basic metrics export (Prometheus endpoint).
8. **Documentation**
    - Produce runbooks: `docs/RELEASE.md`, `docs/DB_MIGRATIONS.md`, `docs/SECURITY.md`, and `infra/README.md`.

---

# Practical checklists & conventions to adopt

**Code & repo**

- Use workspace package boundaries for imports (no relative `../../..` across packages).
- `shared-types` is the source of truth for DTOs.
- Keep domain logic in `api/src/domain` and avoid framework code leaks into domain.

**DB / Prisma**

- PRs changing schema must include generated migration files.
- CI runs migrations on ephemeral DB and runs `prisma generate`.
- Clear seeding scripts for dev / test.

**Workers & Jobs**

- All scheduled tasks must be idempotent.
- Implement dead-letter queue and retry policy.

**Security & Secrets**

- Use secrets manager (do not store in repo).
- Enforce static scanning (Snyk/Dependabot) in CI.

**Testing**

- Unit: run in every PR for changed packages.
- Integration/E2E: run in main branch pipeline using ephemeral infra.
- Contract tests between api and sdk/shared-types.

**Naming**

- Continue with kebab-case files and PascalCase for classes.
- Decide whether to keep `I` prefix for interfaces; if so, add linter rule to enforce it.

# Tradeoffs & rationale

- **Why keep monolith?** — Faster iteration and simpler operations for a small team; avoids distributed complexity while allowing future extraction because boundaries are enforced (per your original reasoning).
- **Why add `worker` & `shared-types` now?** — Because your product requires background consolidation (on-chain audits) and strong cross-client contracts. These are features that pay back early by preventing duplicated logic, and they reduce risk when adding mobile or third-party integrations.
- **Why OpenAPI & SDK?** — Keeps frontend/mobile consistently typed and reduces integration bugs between clients and server — important when points and balances are money-adjacent.

---

# Concrete proposed `package.json` workspace (example)

Add to root `package.json`:

```json
{
  "name": "rewards-bolivia",
  "private": true,
  "workspaces": [
    "packages/*"
  ],
  "scripts": {
    "dev": "turbo run dev --parallel",
    "build": "turbo run build",
    "lint": "turbo run lint",
    "test": "turbo run test"
  },
  "devDependencies": {
    "turbo": "^1.0.0"
  }
}

```

(You can use pnpm/workspaces + Turborepo to speed up pipelines and caching. This is optional but recommended.)

---

# Actionable next steps (what you can do now)

1. Create `packages/shared-types` and move a small set of DTOs to it (e.g., `UserDTO`, `PointsTransactionDTO`).
2. Add a path mapping in `tsconfig` so `web` can import `@shared-types/*`.
3. Create a minimal `packages/worker` that connects to Redis/queue and can run a dummy job.
4. Add an OpenAPI generation endpoint to `api` and generate `packages/sdk` locally.
5. Add CI job for migrations: `prisma migrate deploy --preview-feature` against ephemeral DB and run smoke test.

If you want, I can generate the concrete `tsconfig` path mapping, an example `shared-types` index file, and a starter `worker.ts` file (code) in this conversation — tell me which piece to generate first and I’ll produce it directly.

---

# Risks if you don't act

- Duplication and drift across frontend/mobile APIs → more bugs.
- Harder to extract services later due to ad-hoc dependencies.
- Background processing for auditing left undefined → operational incidents or audit gaps.
- Migration drift and DB issues between environments.

# About Testing ?

Tests are critical; their placement affects developer experience, CI speed, encapsulation, and how reliably you catch regressions. Below I give a focused recommendation for where every type of test should live in the Rewards Bolivia monorepo, **why** each belongs there, and concrete, actionable layout examples and rules you can enforce.

---

# Summary recommendation (short)

- **Unit tests:** colocate with the code they test (same package), alongside source files in `__tests__` or with `.spec.ts` next to implementation.
- **Integration tests:** live in a package-level `test/integration` folder (close to the module under test) and run with a test database or mocked infra.
- **End-to-end (E2E) tests:** place at the package that represents the boundary (e.g., `packages/api/test/e2e` for API role e2e; `packages/web/e2e` or top-level `e2e/` for cross-package user flows). Use a dedicated `e2e` suite that runs against deployed or ephemeral infra.
- **Contract / API contract tests:** place alongside `packages/shared-types` or `packages/api/test/contracts` and also in CI to validate OpenAPI ↔ SDK ↔ frontend.
- **Test utilities / fixtures / seeds:** put in a shared package like `packages/libs/testing` or `packages/test-utils` so all packages can reuse deterministic fixtures, custom matchers, and test helpers.
- **E2E test runner config and test data / snapshots:** keep under `packages/web/e2e` or top-level `e2e/` depending on scope.

---

# Why colocate unit tests with source files (detailed)

1. **Discoverability & cognitive load:** When tests live next to the implementation (`src/module/foo.service.ts` + `src/module/foo.service.spec.ts`) developers can immediately see how code is covered and update tests while changing code.
2. **Refactoring safety:** Renames and refactors are easier because tests move with the files (IDE/tooling picks them up).
3. **Faster, smaller test runs:** Per-package unit tests can be run in isolation, making development feedback loops fast.
4. **Consistent imports/tsconfig:** Colocated tests use the same relative imports and TS config as the code under test, avoiding cross-package import complexities.

**Pattern:** use `.spec.ts` or `.test.ts` suffix, or a sibling `__tests__` folder — be consistent across the repo.

---

# Why integration tests live at package-level `test/integration`

1. **Encapsulation:** Integration tests often exercise module boundaries (e.g., controllers + repository + DB). Keeping them in `packages/api/test/integration` makes it clear what external systems they need (Postgres, Redis).
2. **Infrastructure control:** It's easier to wire up ephemeral containers (docker-compose or testcontainers) when tests are grouped by package. CI can spin up only the required infra for those tests.
3. **Performance control:** Integration tests are slower than unit tests — grouping allows CI to schedule them separately (e.g., in a different job or only when backend code changes).

**Example path:** `packages/api/test/integration/transactions.integration.spec.ts`

---

# Why E2E tests should be separate and boundary-focused

1. **Cross-system scenarios:** E2E tests validate the full user flow (web + api + worker + database). They’re best isolated in a top-level `e2e/` folder (or `packages/web/e2e` if they are UI-focused).
2. **Deployment parity:** E2E tests usually run against ephemeral environments or staging deployments. Keeping them at top-level makes CI setup easier (one job spins up full infra and runs all e2e suites).
3. **Tooling separation:** UI E2E usually uses Cypress/Playwright, API E2E may use Supertest or REST client — keeping config and fixtures together simplifies runner setup.

**Two viable placements:**

- `e2e/` (top-level) — for cross-package flows that exercise the entire system.
- `packages/web/e2e` and `packages/api/test/e2e` — when you want to run UI and API e2e independently.

---

# Test utilities, fixtures & seeds: one shared place

Create a small workspace package: `packages/test-utils` (or `packages/libs/testing`).

Why:

- **DRY:** avoid duplicating factories, JWT helpers, mock servers, and deterministic data generators.
- **Consistency:** single place to update test seeds or DB factory behavior.
- **Versioning & maintenance:** tests across packages all depend on the same test helpers.

**Contents to include:** `db-fixtures.ts`, `mock-aws.ts`, `jwt-test-helper.ts`, `jest-setup.ts`, `test-logger.ts`, `prisma-seed.ts`.

---

# Contract testing / OpenAPI validation

- Keep API contract tests near the API spec: `packages/api/test/contracts`.
- Also add consumer-driven contract checks in `packages/web` or in `packages/sdk` CI to ensure the generated SDK remains compatible.

Why:

- Contracts change often; placing tests close to the contract generation ensures they get updated alongside schema changes.

---

# Recommended concrete directory tree with tests included

```
/rewards-bolivia
├── packages/
│   ├── api/
│   │   ├── src/
│   │   │   └── modules/
│   │   │       └── transactions/
│   │   │           ├── transactions.service.ts
│   │   │           └── transactions.service.spec.ts        # unit (colocated)
│   │   ├── test/
│   │   │   ├── integration/
│   │   │   │   └── transactions.integration.spec.ts       # integration (DB, prisma)
│   │   │   └── e2e/
│   │   │       └── api.e2e-spec.ts                        # API-level e2e
│   │   └── test-setup/                                    # local test scaffolding
│   ├── web/
│   │   ├── src/
│   │   │   └── components/
│   │   │       └── LoginForm.test.tsx                     # unit/component test
│   │   ├── e2e/                                          # Cypress or Playwright tests
│   │      └── login.cy.ts
│   │   
│   ├── worker/
│   │   └── src/
│   │       └── reconciliation.worker.spec.ts              # unit tests for worker functions
│   ├── shared-types/
│   │   └── test/
│   │       └── contracts.spec.ts                         # contract tests vs swagger
│   ├── test-utils/                                       # shared test helpers (workspace package)
│   │   ├── src/
│   │   │   └── prisma-fixtures.ts
│   │   └── package.json
├── e2e/                                                  # top-level cross-package e2e (optional)
│   ├── cypress/
│   └── playwright/
└── jest.workspaces.config.js

```

---

# Naming & test file conventions (enforceable)

- Unit tests: `.spec.ts` or `.test.ts` colocated with implementation.
- Integration tests: `test/integration/*.spec.ts`.
- E2E tests: `test/e2e/*.spec.ts` or in top-level `e2e/`.
- Snapshot files: keep in `__snapshots__` next to the test that created them.
- Test data / fixtures: in `packages/test-utils/src/fixtures/*`.

Add lint / repo rules to enforce this pattern (e.g., ESLint plugin that flags test files outside allowed directories).

---

# CI considerations (how placement helps CI)

- **Per-package test caching:** colocated unit tests mean selective CI can run only changed packages’ unit tests.
- **Separate jobs:** integration/e2e tests can run in separate jobs requiring ephemeral infra; unit tests remain fast for PR feedback.
- **Migration safety:** integration tests for `api` that run migrations against ephemeral DB can be gated into CI for merges to `main`.
- **Artifact promotion:** test results for e2e should be required to promote builds to staging/production.

---

# Specific guidance for database-backed tests (Prisma)

- **Unit tests:** mock Prisma client or use `prisma-client` with in-memory abstractions where possible.
- **Integration tests:** run `prisma migrate deploy` or `prisma db push` on ephemeral DB in test setup, then run fixtures from `packages/test-utils`.
- **E2E tests:** use seeded data and deterministic IDs; teardown should drop DB or reset to known state.

---

# Example: where `app.e2e-spec.ts` should live and why

- Place: `packages/api/test/e2e/app.e2e-spec.ts`.
- Why: It exercises API endpoints and needs direct access to NestJS bootstrap and test utilities in the api package. It can import `test-utils` for seeding and runs against the NestJS application instance (or a deployed service depending on CI).

---

# Checklist you can apply now

- [ ]  Create `packages/test-utils` and move shared fixtures/helpers into it.
- [ ]  Standardize unit test colocated rule and add to `CONTRIBUTING.md`.
- [ ]  Make an `api/test/integration` folder and move current integration tests there.
- [ ]  Add `packages/web/e2e` with Cypress/Playwright config and example test.
- [ ]  Update CI to:
    - run unit tests per-changed-package,
    - run integration tests for `api` when backend code changes,
    - run top-level e2e on stage release pipelines only.
- [ ]  Add a linter rule (or CI check) that flags tests that import production-only modules (e.g., `aws-sdk`) without using mocks.

---