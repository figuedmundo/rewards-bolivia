# AI Task Template: Rewards Bolivia Feature Development

> **Purpose**: This template provides a systematic framework for planning and executing new features for the Rewards Bolivia project. It ensures consistency, quality, and alignment with the project's architectural and product goals.

---

## 1. Task Overview

### Task Title
**Title:** T5.11: Register `BURN` in `PointLedger`

### Goal Statement
**Goal:** To explicitly and auditably record the "burning" of points as a distinct transaction type in the `PointLedger`. This ensures that every point removed from circulation via the transaction fee mechanism is fully traceable, supporting economic stability and transparent accounting.

---

## 2. Strategic Analysis & Solution Options

> **AI Agent Note:** Strategic analysis is not required for this task. The implementation path is well-defined by the existing architecture and economic model. The primary task is to extend the `PointLedger` to support a new transaction type, which is a straightforward enhancement.

---

## 3. Project Context & Current State

### Technology Stack
This feature will be built within the established Rewards Bolivia technical environment.

```yaml
Project Name: Rewards Bolivia
Technology Stack:
  Backend: NestJS (Node.js + TypeScript)
  Web App (Dashboard): React (Vite + Tailwind CSS + shadcn/ui)
  Database (Primary): PostgreSQL
  ORM / DB Toolkit: Prisma
  Caching: Redis
  Blockchain (Audit): Polygon (PoS)
  Infrastructure: Docker & Kubernetes (K8s)
  CI/CD: GitHub Actions
  Testing: Jest (Unit), Playwright (E2E), k6 (Load)
```

### Architecture
```yaml
Key Architectural Patterns:
  - Modular Monolith
  - Domain-Driven Design (DDD)
  - Clean Architecture
  - Hybrid Off-chain/On-chain (Proof-of-Audit)
  - Event-driven (for asynchronous tasks)
```
For more details, see the [Architecture Guide](../../docs/ARCHITECTURE.md).

### Current State
The `redeem` transaction flow calculates a `burnAmount` as a percentage of the points being redeemed. This amount is correctly deducted from the business's point balance. However, the act of burning is not explicitly recorded as a separate, identifiable event in the `PointLedger`. The ledger only shows the `REDEEM` transaction, and the burned points are implicitly removed. This task will make the burning explicit.

---

## 4. Feature Definition

### Problem Statement
For robust accounting and economic analysis, every change in the total point supply must be explicitly recorded. Currently, points burned during a redemption are removed from the business's balance but are not logged as a `BURN` event in the `PointLedger`. This makes it difficult to audit the total supply of points and track the impact of the transaction fee over time.

### Success Criteria (MVP)
- [ ] When a `redeem` transaction occurs, a new entry of type `BURN` is created in the `PointLedger` table.
- [ ] The `BURN` entry must contain the `burnAmount`, a reference to the parent `transactionId`, a `reason` (e.g., 'operational_fee'), and a timestamp.
- [ ] The creation of the `REDEEM` and `BURN` ledger entries must occur within the same atomic database transaction.
- [ ] Existing integration tests for the redemption flow must be updated to assert that the `BURN` ledger entry is created correctly.

---

## 5. Technical Requirements

### Functional Requirements
- **System Requirement 1:** The system must add a `BURN` type to the `LedgerEntryType` enum in the Prisma schema.
- **System Requirement 2:** The `PrismaTransactionRepository` (or equivalent infrastructure layer component) must be modified to create two ledger entries within the `redeem` database transaction: one for `REDEEM` and one for `BURN`.
- **System Requirement 3:** The `amount` for the `BURN` entry must be the calculated `burnAmount`. The `amount` for the `REDEEM` entry remains the total `pointsUsed`.

### Non-Functional Requirements
- **Atomicity:** The creation of the `Transaction`, `REDEEM` ledger entry, `BURN` ledger entry, and all balance updates must succeed or fail together as a single atomic unit.
- **Auditability:** The `BURN` entry enhances the audit trail, providing a clear record of all points permanently removed from circulation.

---

## 6. Data & Database Changes

### Data Model Updates (Prisma Schema)
The `LedgerEntryType` enum in `schema.prisma` needs to be updated.

```prisma
// packages/api/prisma/schema.prisma

enum LedgerEntryType {
  EMIT
  REDEEM
  TRANSFER
  BURN // Add this new type
  EXPIRE
}

model PointLedger {
  id              String          @id @default(cuid())
  transactionId   String
  userId          String
  type            LedgerEntryType
  amount          Int
  balanceBefore   Int
  balanceAfter    Int
  reason          String?
  createdAt       DateTime        @default(now())

  transaction     Transaction       @relation(fields: [transactionId], references: [id])
  user            User              @relation(fields: [userId], references: [id])

  @@index([transactionId])
  @@index([userId])
}
```

---

## 7. API & Backend Changes

No API endpoint changes are required. This is a backend-only change to the implementation of the existing `POST /api/v1/transactions/redeem` endpoint. The core logic change will be within the `PrismaTransactionRepository`'s `redeem` method.

---

## 8. Frontend Changes

No frontend changes are required for this task.

---

## 9. Implementation Plan & Tasks

### Milestone 1: Backend Implementation & Testing
- **Task 1.1:** Update the `LedgerEntryType` enum in `packages/api/prisma/schema.prisma` to include `BURN`.
- **Task 1.2:** Run `pnpm --filter api exec prisma generate` to update the Prisma client with the new enum type.
- **Task 1.3:** Modify the `redeem` method in the `PrismaTransactionRepository` to create an additional `PointLedger` entry with the type `BURN`.
    - This entry should be created within the existing `prisma.$transaction` block.
    - The `userId` for the `BURN` entry should be the business's ID, as they are the ones "paying" the fee.
    - The `reason` field can be set to `'OPERATIONAL_FEE'`.
- **Task 1.4:** Update the integration tests in `packages/api/test/integration/transactions.controller.integration.spec.ts` to:
    - Query the `PointLedger` after a redemption.
    - Assert that two entries are created for the transaction: one `REDEEM` and one `BURN`.
    - Verify the `amount`, `type`, and `reason` for the `BURN` entry are correct.

---

## 10. Risk Assessment

| Risk | Likelihood | Impact | Mitigation Strategy |
| :--- | :--- | :--- | :--- |
| **Inconsistent Ledger** | Low | Medium | The primary mitigation is to ensure the new `BURN` entry is created within the same `prisma.$transaction` block as all other database writes for the redemption flow. This guarantees atomicity. |
| **Incorrect Balance Calculation** | Low | Medium | The existing logic for balance updates already accounts for the `burnAmount`. The integration tests must be updated to re-verify that the final business balance is correct after both the `REDEEM` and `BURN` have been accounted for. |

---

## 11. AI Agent Instructions

### Implementation Workflow
üéØ **MANDATORY PROCESS:**
1.  **Analyze & Plan:** Start by reading this entire plan.
2.  **Backend First:** This is a backend-only task.
    - Modify the Prisma schema.
    - Update the repository layer to include the `BURN` ledger entry.
    - Update the corresponding integration tests to validate the change.
3.  **Review & Refactor:** Ensure the new code follows existing patterns and that all tests pass.

‚öôÔ∏è **Quality Assurance Loop:**
- **Lint and Build Incrementally:** After each small, logical change, run `pnpm --filter api lint` and `pnpm --filter api build`.
- **Zero Linting Errors:** Do not consider the task complete until the linter passes without any errors.
- **Prioritize Type Safety:** Ensure the new `LedgerEntryType.BURN` is used in a type-safe manner.
